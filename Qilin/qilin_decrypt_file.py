import sys
import io
import os
import shutil
import struct
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA256
from Crypto.Util import Counter
from Crypto.Cipher import AES
from Crypto.Cipher import ChaCha20


RANSOM_EXT = '.xxxxxxxxxx'


# RSA
RSA_KEY_SIZE = 512
# AES / ChaCha20
KEY_SIZE = 32
IV_SIZE = 16
AES_CTR_COUNTER_SIZE = 8
AES_CTR_SUFFIX_SIZE = 8
CHACHA_NONCE_SIZE = 12

METADATA_SIZE = RSA_KEY_SIZE

# Marker
MARKER = '-----END CIPHERTEXT BLOCK-----'
MARKER_SIZE = len(MARKER) + 8


ENC_BLOCK_SIZE = 0x80000


def rsa_decrypt(enc_data: bytes, priv_key_data: bytes) -> bytes:
    """RSA OAEP decrypt data"""

    key = RSA.import_key(priv_key_data)
    decryptor = PKCS1_OAEP.new(key, hashAlgo=SHA256)

    try:
        return decryptor.decrypt(enc_data)
    except ValueError:
        return None


def decrypt_file(filename: str, priv_key_data: bytes) -> bool:
    """Decrypt file"""

    with io.open(filename, 'rb+') as f:

        # Read metadata
        try:
            f.seek(-(METADATA_SIZE + MARKER_SIZE), 2)
        except OSError:
            return False

        enc_metadata = f.read(METADATA_SIZE)

        # Decrypt metadata
        metadata = rsa_decrypt(enc_metadata, priv_key_data)
        if metadata is None:
            return False

        # Parse metadata
        pos = 0
        # AES/ChaCha20 key
        key = metadata[pos : pos + KEY_SIZE]
        pos += KEY_SIZE
        # AES/ChaCha20 IV
        iv = metadata[pos : pos + IV_SIZE]
        pos += IV_SIZE
        # Chunk size, chunk space
        chunk_size, chunk_space = struct.unpack_from('<2Q', metadata, pos)
        pos += 16
        # Encryption algorithm (0 - ChaCha20, 1 - AES CTR)
        enc_alg = metadata[pos]

        # Remove metadata
        f.seek(-(METADATA_SIZE + MARKER_SIZE), 2)
        f.truncate()

        # Decrypt data
        if enc_alg != 0:
            # AES CTR
            init_val = int.from_bytes(iv[:AES_CTR_COUNTER_SIZE],
                                      byteorder='little')
            suffix = iv[AES_CTR_COUNTER_SIZE :
                        AES_CTR_COUNTER_SIZE + AES_CTR_SUFFIX_SIZE]
            counter = Counter.new(AES_CTR_COUNTER_SIZE * 8,
                                  suffix=suffix, initial_value=init_val,
                                  little_endian=True)
            cipher = AES.new(key, AES.MODE_CTR, counter=counter)
        else:
            # ChaCha20
            cipher = ChaCha20.new(key=key, nonce=iv[:CHACHA_NONCE_SIZE])

        # Decrypt chunks
        pos = 0

        while True:

            # Decrypt chunk
            p = pos
            size = chunk_size
            while size != 0:

                block_size = min(size, ENC_BLOCK_SIZE)
                f.seek(p)
                enc_data = f.read(block_size)
                if enc_data == b'':
                    break

                dec_data = cipher.decrypt(enc_data)

                f.seek(p)
                f.write(dec_data)

                size -= block_size
                p += block_size

            else:
                pos += chunk_size + chunk_space
                continue

            break

    return True


#
# Main
#
if len(sys.argv) != 2:
    print('Usage:', os.path.basename(sys.argv[0]), 'filename')
    sys.exit(0)

filename = sys.argv[1]

with io.open('rsa_privkey.pem', 'rb') as f:
    priv_key_data = f.read()

# Copy file
new_filename = filename
if new_filename.endswith(RANSOM_EXT):
    new_filename = new_filename[:-len(RANSOM_EXT)]
else:
    new_filename += '.dec'
shutil.copy(filename, new_filename)

# Decrypt file
if not decrypt_file(new_filename, priv_key_data):
    print('Error: Failed to decrypt file')
    sys.exit(1)
